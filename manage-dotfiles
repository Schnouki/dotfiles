#!/usr/bin/python3

import argparse
import hashlib
import os
import subprocess as subp
import sys
import tempfile
from pathlib import Path


FILES = {
    ".atlas/auth": "atlas-auth.gpg",
    ".gitspindle": "gitspindle.gpg",
    ".gnupg/gpg.conf": "gpg.conf.gpg",
    ".msmtprc": "msmtprc.gpg",
    ".netrc": "netrc.gpg",
    ".npmrc": "npmrc.gpg",
    ".mbsyncrc": "mbsyncrc.gpg",
    ".notmuch-config": "notmuch/config.gpg",
    ".ssh/config": "ssh.gpg",
    ".transifexrc": "transifexrc.gpg",
    ".config/pws.yaml": "pws.yaml.gpg",
    ".config/emacs/init-99-private.el": "emacs/init-99-private.el.gpg",
    ".config/fish/conf.d/doist.fish": "fish/conf.d/doist.fish.gpg",
    ".config/fish/conf.d/private.fish": "fish/conf.d/private.fish.gpg",
    ".config/imapfilter/config.lua": "imapfilter/config.lua.gpg",
    ".config/mpdasrc": "mpdasrc.gpg",
    ".config/notmuch/autotag.py": "notmuch/autotag.py.gpg",
    ".config/swww/choose-folder": "swww/choose-folder.gpg",
    ".config/zsh/private": "zsh/private.gpg",
}

TARBALLS = {
    "Age": ("age.tar.gpg", ".config/age/*"),
    "Calibre": ("calibre.tar.gpg", ".config/calibre/*"),
    "Pgweb": ("pgweb.tar.gpg", ".pgweb/**/**"),
    "Tmuxp": ("tmuxp.tar.gpg", ".tmuxp/*"),
    "Weechat": ("weechat.tar.gpg", ".config/weechat/*.conf"),
}

HOME = Path.home()
CONFIG = HOME / ".config"

_filters = {}


def filter(filename):
    def wrapper(func):
        _filters[filename] = func
        return func

    return wrapper


class TempPath(os.PathLike):
    def __init__(self):
        self.tmpf = tempfile.NamedTemporaryFile()

    def __fspath__(self):
        return self.tmpf.name

    @property
    def path(self):
        return Path(self.tmpf.name)


@filter(".netrc")
def filter_netrc(fp: Path) -> os.PathLike:
    data = fp.read_text()
    new_data = []
    machine, login = "", ""
    for line in data.splitlines():
        if not line.strip():
            continue
        words = line.strip().split()
        if words[0] == "machine":
            machine, login = words[1], ""
        elif words[0] == "login":
            login = words[1]
        elif (
            words[0] == "password"
            and machine.endswith(".amazonaws.com")
            and login == "aws"
        ):
            line = "\tpassword ***"
        new_data.append(line)
    outp = TempPath()
    outp.path.write_text("\n".join(new_data))
    return outp


def md5(buf: bytes) -> str:
    hh = hashlib.md5()
    hh.update(buf)
    return hh.hexdigest()


def get_last_update_filename(name: str) -> str:
    dst_name = CONFIG / name
    dst_hash = md5(str(dst_name).encode() + b"\n")
    return f".last_update_{dst_hash}"


def update_encrypted_files(force: bool):
    for src, dst in FILES.items():
        src_p = HOME / src
        dst_p = CONFIG / dst
        uf_p = CONFIG / get_last_update_filename(dst)

        if not src_p.exists():
            print(f"Missing source file: {src}")
            continue

        if (
            force
            or not dst_p.exists()
            or not uf_p.exists()
            or src_p.stat().st_mtime > uf_p.stat().st_mtime
        ):
            print(f"New version of {src} found, encrypting it...")

            if filter_func := _filters.get(src):
                print(f"  applying {filter_func.__name__}...")
                src_p = filter_func(src_p)

            dst_p.unlink(missing_ok=True)
            subp.run(
                [
                    "gpg2",
                    "--quiet",
                    "--batch",
                    "--output",
                    dst_p,
                    "--encrypt",
                    Path(src_p),
                ],
                check=True,
            )
            uf_p.touch()


def update_encrypted_tarballs(force: bool):
    for name, (dst, pattern) in TARBALLS.items():
        src_ps = sorted(list(HOME.glob(pattern)))
        dst_p = CONFIG / dst
        uf_p = CONFIG / get_last_update_filename(dst)

        # Inspired by https://github.com/maxmcd/reptar
        tar_cmd = [
            "tar",
            "--sort=name",
            "--mtime='1970-01-01 00:00:00Z'",
            "-c",
            "-C",
            HOME,
        ]
        tar_cmd += [p.relative_to(HOME) for p in src_ps]
        tar_data = subp.run(tar_cmd, check=True, capture_output=True).stdout
        tar_hh = md5(tar_data)
        uf_hh = "" if not uf_p.exists() else uf_p.read_text()

        if force or not dst_p.exists() or not uf_p.exists() or tar_hh != uf_hh:
            print(f"New version of {name} found, encrypting it...")
            dst_p.unlink(missing_ok=True)
            subp.run(
                ["gpg2", "--quiet", "--batch", "--output", dst_p, "--encrypt"],
                check=True,
                input=tar_data,
            )
            uf_p.write_text(tar_hh)


def cmd_install(force: bool):
    hook_path = Path(".git/hooks/pre-commit")
    if hook_path.exists() and not force:
        print("A pre-commit hook is already installed!")
        sys.exit(1)

    script_path = Path(__file__)

    script_content = f"""#!/usr/bin/bash

exec "{script_path}" encrypt "$@"
"""
    hook_path.write_text(script_content)


def cmd_encrypt(force: bool):
    update_encrypted_files(force)
    update_encrypted_tarballs(force)


def cmd_list(force: bool):
    dir_names = {p.name for p in CONFIG.glob(".last_update_*")}
    known_names = {get_last_update_filename(dst): src for src, dst in FILES.items()}
    known_names.update(
        {
            get_last_update_filename(data[0]): f"{name} tarball"
            for name, data in TARBALLS.items()
        }
    )
    known_names_set = set(known_names.keys())

    present_names = dir_names & known_names_set
    missing_names = known_names_set - dir_names
    unknown_names = dir_names - known_names_set

    if present_names:
        print("PRESENT UPDATE FILES:")
        for name in present_names:
            print(f"{known_names[name]}: {name}")
        print()
    if missing_names:
        print("MISSING UPDATE FILES:")
        for name in missing_names:
            print(f"{known_names[name]}: {name}")
        print()
    if unknown_names:
        print("UNKNOWN UPDATE FILES:")
        for name in unknown_names:
            print(name)


if __name__ == "__main__":
    parser = argparse.ArgumentParser("Dotfiles pre-commit hook")
    parser.add_argument("-f", "--force", action="store_true", help="Force update")
    parser.set_defaults(func=cmd_encrypt)
    sp = parser.add_subparsers()

    parser_install = sp.add_parser("install", help="install pre-commit hook")
    parser_install.set_defaults(func=cmd_install)

    parser_list = sp.add_parser("list", help="list update files")
    parser_list.set_defaults(func=cmd_list)

    parser_encrypt = sp.add_parser("encrypt", help="update encrypted files")
    parser_encrypt.set_defaults(func=cmd_encrypt)

    args = parser.parse_args()

    args.func(args.force)
